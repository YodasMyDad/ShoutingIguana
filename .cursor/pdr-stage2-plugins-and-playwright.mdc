# PDR Stage 2 — Playwright Integration & Plugin Foundation

**Working name:** Shouting Iguana  
**Platform:** Windows desktop (WPF, .NET 9)  
**Goal:** Add JavaScript rendering via Playwright and establish the plugin SDK with 3-4 working built-in plugins.

---

## Stage 2 Overview

**Builds on Stage 1** (which delivered basic HTTP crawling and CSV export).

This stage adds:
1. **Playwright** integration for JavaScript-rendered pages
2. **Plugin SDK** contracts and abstractions
3. **Plugin registry** that loads plugins at app startup
4. **3-4 built-in plugins** shipped as separate assemblies (not hot-loadable yet)
5. **Excel export**
6. **Enhanced crawl features**: meta extraction, redirects tracking, image audits

**Key Outcome:** User can crawl JavaScript-heavy sites (SPAs), see findings from multiple analyzer plugins, and export to Excel. Plugins work but require app restart to load new ones (hot-loading comes in Stage 3).

---

## 1) In Scope (Stage 2)

### Playwright Integration
- **Installation & Setup**
  - Add `Microsoft.Playwright` NuGet package
  - First-run browser installation flow:
    - On app startup, check if Chromium installed
    - If missing, show progress dialog and run `playwright install chromium`
    - Progress bar with status (downloading, installing, verifying)
    - Store installation state in app settings
  - Manual reinstall option in Tools menu
  
- **Browser Management**
  - Shared browser instance (singleton `IBrowser`)
  - Browser context pool (configurable, default: 2 contexts)
  - Page lifecycle:
    - Navigate to URL
    - Wait for network idle (or timeout: 30s)
    - Extract rendered HTML
    - Extract headers from final response
    - Capture redirect chain
    - Cleanup page after processing
  - Configurable viewport (default: 1920x1080)
  - User-agent override (same as Stage 1)
  - Headless mode (default: true)
  
- **Fetcher Updates**
  - Replace HttpClient fetcher with Playwright fetcher
  - Fallback to HttpClient for non-HTML resources (images, CSS, JS files) to save browser overhead
  - Capture both initial request and final response after redirects
  - Store redirect chain in database
  
- **Memory Management**
  - Limit concurrent browser pages (default: 2, configurable)
  - Dispose pages after processing
  - Monitor memory usage (log warning if exceeds 1.5 GB)
  - Graceful browser restart if memory threshold exceeded

### Plugin SDK Package
Create new project: `ShoutingIguana.PluginSdk` (NuGet package)

**Contracts & Interfaces**
```csharp
namespace ShoutingIguana.PluginSdk;

public interface IPlugin
{
    string Id { get; }           // e.g., "com.shoutingiguana.brokenlinks"
    string Name { get; }         // e.g., "Broken Links Analyzer"
    Version Version { get; }
    void Initialize(IHostContext context);
}

public interface IUrlTask
{
    string Key { get; }          // e.g., "BrokenLinks"
    string DisplayName { get; }  // e.g., "Broken Links"
    int Priority { get; }        // Execution order (lower = earlier)
    Task ExecuteAsync(UrlContext ctx, CancellationToken ct);
}

public interface IExportProvider
{
    string Key { get; }
    string DisplayName { get; }
    string FileExtension { get; }  // e.g., ".csv" or ".xlsx"
    Task<ExportResult> ExportAsync(ExportContext ctx, CancellationToken ct);
}

public sealed record UrlContext(
    Uri Url,
    IBrowserPage? Page,            // Abstraction over Playwright IPage
    HttpResponseMessage? HttpResponse,
    string? RenderedHtml,
    IReadOnlyDictionary<string, string> Headers,
    ProjectSettings Project,
    IFindingSink Findings,
    IUrlEnqueue Enqueue,
    ILogger Logger);

public interface IBrowserPage
{
    Task<string> ContentAsync();
    Task<IElementHandle?> QuerySelectorAsync(string selector);
    Task<IElementHandle[]> QuerySelectorAllAsync(string selector);
    Task<T> EvaluateAsync<T>(string expression);
    Task<string?> GetAttributeAsync(IElementHandle element, string name);
    Task<string?> GetTextContentAsync(IElementHandle element);
}

public interface IFindingSink
{
    Task ReportAsync(string taskKey, Severity severity, string code, string message, object? data = null);
}

public enum Severity { Info, Warning, Error }

public interface IHostContext
{
    void RegisterTask(IUrlTask task);
    void RegisterExport(IExportProvider export);
    ILogger CreateLogger(string categoryName);
}
```

**Base Classes for Convenience**
```csharp
public abstract class UrlTaskBase : IUrlTask
{
    public abstract string Key { get; }
    public abstract string DisplayName { get; }
    public virtual int Priority => 100;
    
    public abstract Task ExecuteAsync(UrlContext ctx, CancellationToken ct);
}
```

**Plugin Metadata Attribute**
```csharp
[AttributeUsage(AttributeTargets.Class)]
public class PluginAttribute : Attribute
{
    public string Id { get; set; } = "";
    public string Name { get; set; } = "";
    public string MinSdkVersion { get; set; } = "1.0.0";
}
```

### Plugin Registry (Core App)
- **Plugin Discovery**
  - Scan `plugins/` folder in app directory
  - Load all `.dll` files
  - Use reflection to find types implementing `IPlugin`
  - Validate `[Plugin]` attribute
  - Check `MinSdkVersion` compatibility
  
- **Plugin Initialization**
  - Call `IPlugin.Initialize(hostContext)`
  - Plugins register their tasks/exporters via `hostContext`
  - Build registry of all registered tasks and exporters
  
- **Plugin Lifecycle** (Stage 2 - Simple)
  - Load at app startup
  - **No hot-loading yet** (requires app restart to load new plugins)
  - **No unloading** (no AssemblyLoadContext yet)
  - Store enabled/disabled state in app settings
  
- **Task Execution**
  - CrawlEngine maintains list of registered `IUrlTask` instances
  - After fetching each URL, execute all tasks in priority order
  - Each task receives `UrlContext` with page/HTML/headers
  - Tasks call `Findings.ReportAsync()` to persist findings

### Database Schema Updates
Add **Findings** table:
```
id (int, PK)
project_id (int, FK)
url_id (int, FK)
task_key (string, indexed)       // e.g., "BrokenLinks"
severity (enum: Info, Warning, Error)
code (string)                     // e.g., "BROKEN_LINK_404"
message (string)                  // e.g., "Link to /missing returns 404"
data_json (string?)               // Additional structured data
created_utc (datetime)
```

Add **Redirects** table:
```
id (int, PK)
url_id (int, FK)
from_url (string)
to_url (string)
status_code (int)
position (int)                    // Order in chain (0 = initial)
```

Add **Images** table:
```
id (int, PK)
url_id (int, FK)                  // Page where image was found
src_url (string)                  // Image URL
alt_text (string?)
width (int?)
height (int?)
http_status (int?)
content_length (int?)
```

Update **Urls** table:
```
Add columns:
- title (string?)
- meta_description (string?)
- canonical_url (string?)
- meta_robots (string?)
- redirect_target (string?)       // Final URL after redirects
```

### Built-in Plugins (Stage 2)

Create 4 built-in plugins as separate assemblies in `src/Plugins/`:

#### 1) **Inventory Plugin** (`ShoutingIguana.Plugins.Inventory`)
- Captures basic URL metadata (already happening in crawl engine)
- Findings: None (just persists URL data)
- Export: URL inventory with status, content-type, depth

#### 2) **Broken Links Plugin** (`ShoutingIguana.Plugins.BrokenLinks`)
- Extracts all links from page (a, img, link, script)
- For each link, check if it was crawled
- If crawled with non-2xx status, report finding
- Finding:
  ```
  Code: BROKEN_LINK
  Message: "Link to {url} returns {status}"
  Data: { source_url, target_url, anchor_text, http_status }
  ```
- Export: source URL, target URL, anchor, status, link type

#### 3) **Titles & Meta Plugin** (`ShoutingIguana.Plugins.TitlesMeta`)
- Extract `<title>` tag
- Extract `<meta name="description">`
- Validate:
  - Missing title → Warning
  - Missing description → Warning
  - Title too short (<30 chars) → Warning
  - Title too long (>60 chars) → Warning
  - Description too short (<50 chars) → Warning
  - Description too long (>160 chars) → Warning
  - Duplicate title (compare with other URLs) → Error
- Save title/description to Urls table
- Export: URL, title, title_length, description, description_length, issues

#### 4) **Redirect Plugin** (`ShoutingIguana.Plugins.Redirects`)
- Capture redirect chain from Playwright response
- Store chain in Redirects table
- Detect:
  - Redirect chains (>3 hops) → Warning
  - Redirect loops → Error
  - Protocol canonicalisation (http→https) → Info
  - WWW canonicalisation issues → Warning
- Export: from_url, to_url, chain_length, status_codes, issues

### Findings View Enhancements
- **Tabbed interface** for different finding types
  - Tab per plugin (Inventory, Broken Links, Titles & Meta, Redirects)
  - Each tab shows findings from that plugin's task
  - Grid with columns: URL, Severity, Code, Message, Created
  - Filter by severity (All, Info, Warning, Error)
  - Search in message/code
  - Row count per tab badge

- **Finding Details Panel**
  - Click a finding row → show detail panel below or to side
  - Show full message, structured data (formatted JSON)
  - "Go to URL" button → opens URL in browser
  
### Excel Export
- Add `ClosedXML` NuGet package
- New export service: `ExcelExportService`
- Export formats:
  - URL Inventory (same as CSV)
  - Broken Links (multi-sheet: Overview + Details)
  - Titles & Meta (one sheet with all columns)
  - Redirects (redirect chains)
- Each export type as separate sheet in workbook
- Auto-fit columns, freeze header row, apply filters

### Menu Updates
**File Menu**
- Export to CSV... → Export → CSV
- **New:** Export to Excel... → Export → Excel

**View Menu**
- Add: Extensions (Ctrl+Shift+E) — shows loaded plugins list (read-only in Stage 2)

**Tools Menu**
- Add: Reinstall Playwright Browsers...

### Settings Dialog
- New modal dialog (Tools → Options)
- Tabs:
  - **Crawling**: concurrency, timeout, memory limit
  - **Browser**: viewport size, headless mode, enable JavaScript
  - **Plugins**: list of loaded plugins (enable/disable checkboxes, restart required notice)

### Enhanced Status Bar
- Add indicator: "Browser Ready" or "Browser Installing..." or "Browser Error"
- Playwright status icon (green checkmark when ready)

---

## 2) Out of Scope (Stage 2)

- Hot-loading plugins (requires AssemblyLoadContext — Stage 3)
- Plugin uninstall/unload
- NuGet feed integration & in-app plugin discovery
- Extensions Manager UI (full-featured)
- Remaining plugins (duplicate content, structured data, custom extraction, etc.)
- Proxy support
- List-mode crawling
- Pause/Resume crawl
- Resume after crash
- Link graph visualization
- Advanced settings (proxy, auth, custom headers)

---

## 3) Architecture Updates

### Project Structure (Stage 2 Additions)
```
ShoutingIguana/
  src/
    ShoutingIguana.PluginSdk/      # NEW: SDK package
      IPlugin.cs
      IUrlTask.cs
      IExportProvider.cs
      UrlContext.cs
      IBrowserPage.cs
      IFindingSink.cs
      PluginAttribute.cs
      UrlTaskBase.cs
      
    ShoutingIguana.Core/
      Services/
        IPlaywrightService.cs       # NEW: Browser management
        PlaywrightService.cs
        IPluginRegistry.cs          # NEW: Plugin discovery/loading
        PluginRegistry.cs
      Browser/                      # NEW: Playwright abstractions
        BrowserPage.cs              # IBrowserPage implementation
        PlaywrightFetcher.cs
        
    ShoutingIguana.Data/
      Models/
        Finding.cs                  # NEW
        Redirect.cs                 # NEW
        Image.cs                    # NEW
      Migrations/
        AddFindingsTables.cs        # NEW migration
        
    Plugins/                        # NEW: Built-in plugins
      ShoutingIguana.Plugins.Inventory/
        InventoryPlugin.cs
        InventoryTask.cs
        InventoryExporter.cs
      ShoutingIguana.Plugins.BrokenLinks/
        BrokenLinksPlugin.cs
        BrokenLinksTask.cs
        BrokenLinksExporter.cs
      ShoutingIguana.Plugins.TitlesMeta/
        TitlesMetaPlugin.cs
        TitlesMetaTask.cs
        TitlesMetaExporter.cs
      ShoutingIguana.Plugins.Redirects/
        RedirectsPlugin.cs
        RedirectsTask.cs
        RedirectsExporter.cs
        
    ShoutingIguana/               # WPF app
      Views/
        FindingsView.xaml           # UPDATED: Tabbed findings
        SettingsDialog.xaml         # NEW
        ExtensionsView.xaml         # NEW (simple list)
      ViewModels/
        FindingsViewModel.cs        # UPDATED
        SettingsViewModel.cs        # NEW
        ExtensionsViewModel.cs      # NEW
      Services/
        ExcelExportService.cs       # NEW
```

### Updated Technology Stack (Stage 2)
```xml
<!-- Add to existing Stage 1 packages -->
<PackageReference Include="Microsoft.Playwright" Version="1.48.0" />
<PackageReference Include="ClosedXML" Version="0.104.1" />
<PackageReference Include="System.Text.Json" Version="9.0.0" />
```

### Plugin Assembly Structure
Each plugin is a class library (.NET 9) that:
1. References `ShoutingIguana.PluginSdk`
2. Contains one `IPlugin` implementation with `[Plugin]` attribute
3. Contains one or more `IUrlTask` implementations
4. Contains optional `IExportProvider` implementations
5. Builds to `plugins/` folder in app output directory

**Build configuration:**
```xml
<PropertyGroup>
  <TargetFramework>net9.0</TargetFramework>
  <OutDir>..\..\ShoutingIguana\bin\$(Configuration)\$(TargetFramework)\plugins\$(AssemblyName)\</OutDir>
</PropertyGroup>
```

---

## 4) Testing Criteria (Stage 2 Complete)

✅ **Playwright Installation**
- First launch → "Installing browser" progress dialog appears
- Chromium downloads and installs successfully (~150 MB)
- Status bar shows "Browser Ready" after installation
- Can manually trigger reinstall from Tools menu

✅ **JavaScript Rendering**
- Crawl a JavaScript-heavy site (e.g., a React SPA)
- Verify rendered content captured (not raw HTML)
- Verify dynamic links extracted
- Verify meta tags from rendered DOM (not source HTML)

✅ **Browser Resource Management**
- Monitor memory during 100-URL crawl with Playwright
- Memory stays under 1.5 GB
- Browser contexts/pages properly disposed
- No browser zombie processes after crawl stops

✅ **Plugin Loading**
- App starts → all 4 built-in plugins loaded
- View → Extensions shows plugin list with names/versions
- Each plugin's tasks registered in task pipeline

✅ **Task Execution**
- Crawl example.com with all plugins enabled
- Verify findings generated by each plugin:
  - Inventory: URL records created
  - Broken Links: If any 404s found, findings reported
  - Titles & Meta: Title/description extracted and validated
  - Redirects: Any redirects captured in chain

✅ **Findings View**
- Findings View shows tabs: Inventory, Broken Links, Titles & Meta, Redirects
- Each tab displays findings from that plugin
- Filter by severity works
- Search works
- Click finding → detail panel shows full data

✅ **Excel Export**
- File → Export → Excel
- Save dialog opens
- .xlsx file created with multiple sheets (one per plugin)
- Open in Excel—data correct, columns auto-sized, headers frozen

✅ **Plugin Enable/Disable**
- Tools → Options → Plugins tab
- Disable "Broken Links" plugin
- Restart app
- Crawl site → no broken links findings generated
- Re-enable → findings return after restart

✅ **Settings Dialog**
- Tools → Options opens settings dialog
- Can change concurrency, timeout, viewport
- Changes persist after app restart
- Validation on invalid values (e.g., negative concurrency)

✅ **Redirect Handling**
- Crawl site with redirect (http→https)
- Redirect chain captured
- Redirects table populated
- Redirect tab shows chain with hops
- Export includes redirect details

✅ **Title & Meta Analysis**
- Crawl site with pages missing titles
- Findings show warnings for missing/short titles
- Crawl site with duplicate titles → error reported
- Export shows title length, description length, issues

---

## 5) Implementation Order (Suggested)

1. **Create PluginSdk project** with all interfaces and base classes
2. **Add Playwright NuGet package** to Core project
3. **Implement PlaywrightService** (browser install, management, lifecycle)
4. **Create IBrowserPage abstraction** over Playwright IPage
5. **Update CrawlEngine** to use PlaywrightFetcher instead of HttpClient
6. **Test basic Playwright crawl** on JavaScript site
7. **Add Findings, Redirects, Images tables** (EF Core migration)
8. **Create PluginRegistry** with discovery and initialization logic
9. **Build Inventory plugin** (simplest, no analysis)
10. **Integrate plugin execution** into CrawlEngine pipeline
11. **Test plugin loading and task execution** end-to-end
12. **Build Broken Links plugin** with link extraction and validation
13. **Build Titles & Meta plugin** with extraction and validation rules
14. **Build Redirects plugin** with chain capture and analysis
15. **Update Findings View** with tabbed interface
16. **Add Excel export service** with ClosedXML
17. **Build Settings dialog** with crawl/browser/plugin settings
18. **Build simple Extensions view** (read-only plugin list)
19. **Polish UI**, test all plugins with diverse sites
20. **Run full acceptance tests**

---

## 6) Success Criteria Summary

**Stage 2 is complete when:**

1. ✅ Playwright Chromium installs automatically on first run
2. ✅ Application can crawl JavaScript-rendered pages (SPAs)
3. ✅ Browser memory managed properly (no leaks, under 1.5 GB)
4. ✅ Plugin SDK contracts defined and documented
5. ✅ 4 built-in plugins load at startup and register tasks
6. ✅ All plugin tasks execute during crawl and generate findings
7. ✅ Findings View shows tabbed interface with plugin-specific findings
8. ✅ Users can filter/search/view findings per plugin
9. ✅ Excel export creates multi-sheet workbook with plugin findings
10. ✅ Settings dialog allows configuring crawl/browser behavior
11. ✅ Extensions view shows loaded plugins (enable/disable requires restart)
12. ✅ Redirect chains captured and analyzed
13. ✅ Title/meta extraction and validation working
14. ✅ Broken links detected and reported with source pages

**When these work, Stage 2 is DONE and you can move to Stage 3.**

---

## 7) Known Limitations (Acceptable in Stage 2)

- Plugins require app restart to load/unload
- No NuGet integration (plugins manually copied to `plugins/` folder)
- No hot-reload via AssemblyLoadContext
- No plugin uninstall capability
- Simple Extensions view (no plugin details, no install/upgrade UI)
- No proxy support
- No list-mode crawling
- No pause/resume crawl
- No crash recovery
- Only 4 plugins (remaining 9 in Stage 3)
- No custom extraction rules
- No advanced authentication

**These are explicitly deferred to Stage 3.**

---

## 8) Developer Experience (Stage 2)

### Creating a New Plugin (Manual)

1. Create new Class Library project (net9.0)
2. Reference `ShoutingIguana.PluginSdk` NuGet package
3. Create plugin class:
   ```csharp
   [Plugin(Id = "com.example.myplugin", Name = "My Plugin")]
   public class MyPlugin : IPlugin
   {
       public string Id => "com.example.myplugin";
       public string Name => "My Plugin";
       public Version Version => new(1, 0, 0);
       
       public void Initialize(IHostContext context)
       {
           context.RegisterTask(new MyTask());
       }
   }
   ```
4. Create task class:
   ```csharp
   public class MyTask : UrlTaskBase
   {
       public override string Key => "MyTask";
       public override string DisplayName => "My Task";
       
       public override async Task ExecuteAsync(UrlContext ctx, CancellationToken ct)
       {
           // Analyze ctx.RenderedHtml, ctx.Page, etc.
           await ctx.Findings.ReportAsync("MyTask", Severity.Info, "MY_CODE", "Found something!");
       }
   }
   ```
5. Build project → DLL outputs to `plugins/MyPlugin/`
6. Restart app → plugin loads automatically

**In Stage 3, this will become `dotnet new shoutingiguana-plugin` and in-app NuGet install.**
